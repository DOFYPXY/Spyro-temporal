//@Description Sketch to reverse a list.
pragma options "--bnd-unroll-amnt 10";

struct node {
	node next;
	int val;	
}

struct stack {
	node top;
}

stack push(stack s, int val) {
    node n = new node();
    stack ret = new stack();

    n.val = val;
    n.next = s.top;
    
    ret.top = n;
    return ret;
}

int pop(stack s, ref stack out) {
    assert s.top != null;
    
    node top = s.top;
    
    stack tail = new stack();
    tail.top = top.next;

    out = tail;
    return top.val;
}

boolean node_equal(node n1, node n2) {
    if (n1 == null || n2 == null) {
        return n1 == n2;
    } else {
        return n1.val == n2.val && node_equal(n1.next, n2.next);
    }
}

boolean stack_equal(stack s1, stack s2) {
    return node_equal(s1.top, s2.top);
}

generator int intGen(int x, int y) {
   int t = ??;
   if(t == 0){ return x; }
   if(t == 1){ return y; }
}

generator stack stackGen(stack s1, stack s2, stack s3, stack s4) {
    int t = ??;
    if (t == 0) { return s1; }
    if (t == 1) { return s2; }
    if (t == 2) { return s3; }
    if (t == 3) { return s4; }
}

generator boolean propertyGen(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) { /* automatically rewritten */
    int t = ??;

    int leftInt = intGen(push_input_val, pop_out_val);
    int rightInt = intGen(push_input_val, pop_out_val);

    if(t == 0) { return leftInt < rightInt; }
    if(t == 1) { return leftInt <= rightInt; }
    if(t == 2) { return leftInt == rightInt; }

    boolean leftBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
    boolean rightBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );

    if(t == 3) { return leftBool && rightBool; }
    if(t == 4) { return leftBool || rightBool; }
    if(t == 5) { return !leftBool; }

    stack leftStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );
    stack rightStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );

    if(t == 6) { return stack_equal(leftStack, rightStack); }
}

boolean stack_spec(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) {
    boolean property = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
    
    return property;
}

boolean stack_spec_obtained(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) {
    return false;
}

boolean check_soundness = false;
boolean check_precision = false;

harness void soundness() {
    int push_input_val = ??;
    stack push_input_stack = ??;
    stack push_out_stack = push(push_input_stack, push_input_val);

    stack pop_input_stack = ??;
    stack pop_out_stack;
    int pop_out_val = pop(pop_input_stack, pop_out_stack);

    if (check_soundness) {
        // new positive example c is not included in [[ phi ]]
        // c in [[ P ]] since output variables are the result of implementation
        assert !stack_spec_obtained(
            push_input_stack, push_input_val, push_out_stack,
            pop_input_stack, pop_out_val, pop_out_stack
        );
    }
}


harness void precision() {
    stack push_input_stack = ??;
    int push_input_val = ??;
    stack push_out_stack = ??;
    stack pop_input_stack = ??; 
    int pop_out_val = ?? ;
    stack pop_out_stack = ??;

    stack push_out_stack_correct = push(push_input_stack, push_input_val);
    stack pop_out_stack_correct;
    int pop_out_val_correct = pop(pop_input_stack, pop_out_stack_correct);

    if (check_precision) {
        // new negative example c is in [[ phi ]]
        assert stack_spec_obtained(
            push_input_stack, push_input_val, push_out_stack,
            pop_input_stack, pop_out_val, pop_out_stack
        );

        // new negative example c is not in [[ phi' ]]
        assert !stack_spec(
            push_input_stack, push_input_val, push_out_stack,
            pop_input_stack, pop_out_val, pop_out_stack
        );
    }
}
