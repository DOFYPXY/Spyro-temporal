//@Description Sketch to reverse a list.
pragma options "--bnd-unroll-amnt 10";

struct node {
	node next;
	int val;	
}

struct stack {
	node top;
}

stack push(stack s, int val) {
    node n = new node();
    stack ret = new stack();

    n.val = val;
    n.next = s.top;
    
    ret.top = n;
    return ret;
}

int pop(stack s, ref stack out) {
    assert s.top != null;
    
    node top = s.top;
    
    stack tail = new stack();
    tail.top = top.next;

    out = tail;
    return top.val;
}

boolean node_equal(node n1, node n2) {
    if (n1 == null || n2 == null) {
        return n1 == n2;
    } else {
        return n1.val == n2.val && node_equal(n1.next, n2.next);
    }
}

boolean stack_equal(stack s1, stack s2) {
    return node_equal(s1.top, s2.top);
}

generator int intGen(int x, int y) {
   int t = ??;
   if(t == 0){ return x; }
   if(t == 1){ return y; }
}

generator stack stackGen(stack s1, stack s2, stack s3, stack s4) {
    int t = ??;
    if (t == 0) { return s1; }
    if (t == 1) { return s2; }
    if (t == 2) { return s3; }
    if (t == 3) { return s4; }
}

generator boolean integrityGen(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) {
    int t = ??;
    int leftInt = intGen(push_input_val, pop_out_val);
    int rightInt = intGen(push_input_val, pop_out_val);    

    if(t == 0) { return leftInt == rightInt; }

    stack leftStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );
    stack rightStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );

    if(t == 1) { return stack_equal(leftStack, rightStack); }    
}

generator boolean propertyGen(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) { /* automatically rewritten */
    int t = ??;

    int leftInt = intGen(push_input_val, pop_out_val);
    int rightInt = intGen(push_input_val, pop_out_val);

    if(t == 0) { return leftInt < rightInt; }
    if(t == 1) { return leftInt <= rightInt; }
    if(t == 2) { return leftInt == rightInt; }

    boolean leftBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
    boolean rightBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );

    if(t == 3) { return leftBool && rightBool; }
    if(t == 4) { return leftBool || rightBool; }
    if(t == 5) { return !leftBool; }

    stack leftStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );
    stack rightStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );

    if(t == 6) { return stack_equal(leftStack, rightStack); }
}

boolean stack_spec(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) {
    boolean integrity = integrityGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
    boolean property = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
    
    return !integrity || property;
}

harness void positive_example_1() {
    node top1 = new node(next = null, val = 0);
    node top2 = new node(next = top1, val = 0);

    stack s0 = new stack(top = null);
    stack s1 = new stack(top = top1);
    stack s2 = new stack(top = top2);

    assert stack_spec(s1, 0, s2, s1, 0, s0);
}

harness void positive_example_2() {
    node next = null;
    node top = new node(next=next, val=6);
    stack s = new stack(top=top);
    stack push_out_stack = push(s, 0);
    node next_0 = null;
    node top_0 = new node(next=next_0, val=1);
    stack stack__0 = new stack(top=top_0);
    stack pop_out_stack = null;
    int pop_out_val_s20 = pop(stack__0, pop_out_stack);

    assert stack_spec(s, 0, push_out_stack, stack__0, pop_out_val_s20, pop_out_stack);
}

harness void positive_example_3() {
  node top = new node(next=null, val=0);
  stack stack_ = new stack(top=top);
  stack push_out_stack = push(stack_, 1);
  node top_0 = new node(next=null, val=2);
  stack stack__0 = new stack(top=top_0);
  stack pop_out_stack;
  int pop_out_val = pop(stack__0, pop_out_stack);

  assert stack_spec(stack_, 1, push_out_stack, stack__0, pop_out_val, pop_out_stack);
}

harness void negative_example_1() {
    node node_ = new node(val=7);
    node top = new node(next=node_, val=0);
    stack s1 = new stack(top=top);
    node node__0 = new node(val=0);
    node top_0 = new node(next=node__0, val=0);
    stack s2 = new stack(top=top_0);
    node node__1 = new node(val=4);
    node top_1 = new node(next=node__1, val=8);
    stack s3 = new stack(top=top_1);
    node node__2 = new node(val=29);
    node top_2 = new node(next=node__2, val=0);
    stack s4 = new stack(top=top_2);

    assert !stack_spec(s1, 8, s2, s3, 12, s4);
}


boolean stack_spec_obtained(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) {
    // return false; added positive example 1
    // return !false || (push_input_val < push_input_val); added negative example 1
    // return (!(push_input_val == push_input_val)) || (pop_out_val <= push_input_val); added positive example 2
    return (push_input_val == push_input_val) && (!(push_input_val == 0));


}

boolean check_soundness = false;
boolean check_precision = false;

harness void soundness() {
    int push_input_val = ??;
    stack push_input_stack = ??;
    stack push_out_stack = push(push_input_stack, push_input_val);

    stack pop_input_stack = ??;
    stack pop_out_stack;
    int pop_out_val = pop(pop_input_stack, pop_out_stack);

    if (check_soundness) {
        // new positive example c is not included in [[ phi ]]
        // c in [[ P ]] since output variables are the result of implementation
        assert !stack_spec_obtained(
            push_input_stack, push_input_val, push_out_stack,
            pop_input_stack, pop_out_val, pop_out_stack
        );
    }
}


harness void precision() {
    stack push_input_stack = ??;
    int push_input_val = ??;
    stack push_out_stack = ??;
    stack pop_input_stack = ??; 
    int pop_out_val = ?? ;
    stack pop_out_stack = ??;

    stack push_out_stack_correct = push(push_input_stack, push_input_val);
    stack pop_out_stack_correct;
    int pop_out_val_correct = pop(pop_input_stack, pop_out_stack_correct);

    if (check_precision) {
        // new negative example c is included in [[ phi ]]
        assert stack_spec_obtained(
            push_input_stack, push_input_val, push_out_stack,
            pop_input_stack, pop_out_val, pop_out_stack
        );

        // new negative example c is not included in [[ P ]]
        assert !(
            stack_equal(push_out_stack, push_out_stack_correct)
            && pop_out_val == pop_out_val_correct
            && stack_equal(pop_out_stack, pop_out_stack_correct)
        );
    }
}
