pragma options "--spmd-max-nproc 2 --bnd-inbits 3 --bnd-cbits 1 --bnd-unroll-amnt 16 --bnd-inline-amnt 3 --bnd-arr1d-size 16 --bnd-arr-size 32 --be:ufunSymmetry --beopt:simplifycex NOSIM"; //  --be:showDAG

package npb;

int SPMD_MAX_NPROC = 2;
include "spmd.skh";

struct LState {
	int ntdivnp;		// total cells per node
	double[ntdivnp] a;
}


LState movein(global int nproc, int pid, global int nt, global double[nt] ga) {
	global int ntdivnp = nt/nproc;
	double[ntdivnp] a;
	int base = ntdivnp*pid;
	for (int i=0; i<ntdivnp; ++i) {
		a[i] = ga[base+i];
	}
	LState ls = new LState(ntdivnp=ntdivnp, a=a);
	return ls;
}

void moveout(global int nproc, int pid, global int nt, ref global double[nt] ga, LState ls) {
	int base = ls.ntdivnp*pid;
	for (int i=0; i<ls.ntdivnp; ++i) {
		ga[base+i] = ls.a[i];
	}
}

// logically the array is double[nz][nx][ny]
// new: [nx][ny][nz]
void spec_x_yz(global int P, global int nx, global int ny, global int nz, global double[nx*ny*nz] a, ref global double[nx*ny*nz] result) {
	assume P>0 : "P>0";
	assume P<=SPMD_MAX_NPROC : "P<=MAX";
	//assume nx%P==0;
	assume ny%P==0 : "ny%P";
	assume nz%P==0 : "nz%P";

	assume nx>=1 && nx <= 16 : "nx";
	assume ny>=1 && ny <= 16 : "ny";
	assume nz>=1 && nz <= 16 : "nz";
	assume nx*ny*nz <= 32 : "nx*ny*nz";
	assume nx*ny*nz/P <= 16 : "nx*ny*nz/P";
	
	// we don't use block now
	for (int x=0; x<nx; ++x) {
		for(int y=0; y<ny; ++y) {
    			for (int z=0; z<nz; ++z) {
    				result[z*(nx*ny) + y*(nx) + x] = a[y*(nx*nz) + x*(nz) + z];
    			}
    		}
    }
}


// n = nx*ny*nz/np
// [nx][ny][nz/np] => [nz/np][nx][ny]
void transpose_local(global int nx, global int ny, global int nz, double[nx*ny*nz/spmdnproc] a, ref double[nx*ny*nz/spmdnproc] b) {
	global int iend = nz;
	global int jend = nx*ny/spmdnproc;
	assert iend*jend==nx*ny*nz/spmdnproc;
	for (int i=0; i<iend; ++i) {
		for (int j=0; j<jend; ++j) {
			b[i*jend + j] = a[i + j*iend]; 
		}
	}
}

// n = nx*ny*nz/np
// [nz/np][nx][ny/np][np] => [nz][nx][ny/np]
void transpose_finish(global int nx, global int ny, global int nz, double[nx*ny*nz/spmdnproc] a, ref double[nx*ny*nz/spmdnproc] b) {
	global int iend = nz/spmdnproc;
	global int jend = nx*ny/spmdnproc; //nz/spmdnproc;
	assert iend*jend*spmdnproc == nx*ny*nz/spmdnproc;
	for (int p=0; p<spmdnproc; ++p) {
		for (int i=0; i<iend; ++i) {
			for (int j=0; j<jend; ++j) {
//				b[p*nz/spmdnproc + i*nz + j] = a[p*nx*ny*nz/(spmdnproc*spmdnproc) + i*nz/spmdnproc + j];
				b[i*nx*ny + p*nx*ny/spmdnproc + j] = a[p*(nx*ny*nz/(spmdnproc*spmdnproc)) + i*(nx*ny/spmdnproc) + j];
			}
		}
	}
}


// transpose a to b
void transpose_x_yz(global int nx, global int ny, global int nz, LState a, ref LState b) {
	global int n = nx*ny*nz/spmdnproc;
	transpose_local(nx, ny, nz, a.a, b.a);
	spmdalltoall(n, b.a, a.a);
	transpose_finish(nx, ny, nz, a.a, b.a);
}


void trans_x_yz(global int P, global int nx, global int ny, global int nz, global double[nx*ny*nz] a, ref global double[nx*ny*nz] result) implements spec_x_yz {
	global int nt = nx*ny*nz;

	spmdfork(P) {
		LState la;
		la = movein(P, spmdpid, nt, a);
		LState lr;
		lr = movein(P, spmdpid, nt, result);
		spmdbarrier();
		transpose_x_yz(nx, ny, nz, la, lr);
		spmdbarrier();
		moveout(P, spmdpid, nt, result, lr);
	}
}
