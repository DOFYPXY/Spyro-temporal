pragma options "-V20 --spmd-max-nproc 2 --bnd-inbits 2 --bnd-cbits 1 --beopt:bndwrand 1000 --bnd-unroll-amnt 4 --bnd-inline-amnt 3 --bnd-arr1d-size 3 --bnd-arr-size 16 --be:ufunSymmetry --be:nosim --beopt:simplifycex NOSIM --beopt:simiters 100 --be:lightverif"; //  --be:showDAG

// this example is the code generated by EliminateFinalStructs for tr1.sk
// but we manually added array bulk access to limit the length to the real length
// otherwise, it will not solve

void movein (global int nproc_1e, int pid_1f, global int nt_20, global double[nt_20] ga_21, ref int _out_22_ntdivnp_s13, ref double[3] _out_22_a_s14)/*tr1.sk:15*/
{
  global int ntdivnp_23;
  ntdivnp_23 = nt_20 / nproc_1e;
  double[ntdivnp_23] a_24;
  int base_25;
  base_25 = ntdivnp_23 * pid_1f;
  assert (ntdivnp_23 <= 8); //Assert at tr1.sk:19 (-6438386288486915679)
  int i_26;
  for(i_26 = 0; i_26 < ntdivnp_23; i_26 = i_26 + 1)/*Canonical*/
  {
    a_24[i_26] = ga_21[base_25 + i_26];
  }
  _out_22_ntdivnp_s13 = ntdivnp_23;
  assert (ntdivnp_23 <= 3); //embedded array size must < max size
  for(int iter_s15 = 0; iter_s15 < ntdivnp_23; iter_s15 = iter_s15 + 1)/*Canonical*/
    _out_22_a_s14[iter_s15] = a_24[iter_s15];
  return;
}
/*tr1.sk:27*/

void moveout (global int nproc_2d, int pid_2e, global int nt_2f, ref global double[nt_2f] ga_30, int ls_31_ntdivnp_s20, double[3] ls_31_a_s21)/*tr1.sk:27*/
{
  int base_32;
  base_32 = ls_31_ntdivnp_s20 * pid_2e;
  int i_33;
  i_33 = 0;
  bit __sa0_34;
  __sa0_34 = 0 < ls_31_ntdivnp_s20;
  while(__sa0_34)
  {
    ga_30[base_32 + i_33] = ls_31_a_s21[i_33];
    i_33 = i_33 + 1;
    __sa0_34 = i_33 < ls_31_ntdivnp_s20;
  }
}
/*tr1.sk:96*/

void sk (global int P_0, global int nx_1, global int ny_2, global int nz_3, global double[(nx_1 * ny_2) * nz_3] a_4, ref global double[(nx_1 * ny_2) * nz_3] result_5)  implements spec/*tr1.sk:96*/
{
  global int nt_6;
  nt_6 = (nx_1 * ny_2) * nz_3;
  spmdfork(P_0)
  {
    int la_7_ntdivnp_s5;
    double[3] la_7_a_s6;
    int la_s2_8_ntdivnp_s7;
    double[3] la_s2_8_a_s8;
    assert (nt_6 >= ((nx_1 * ny_2) * nz_3)); //Array Length Mismatch tr1.sk:100
    movein(P_0, spmdpid, nt_6, a_4, la_s2_8_ntdivnp_s7, la_s2_8_a_s8);
    la_7_ntdivnp_s5 = la_s2_8_ntdivnp_s7;
    la_7_a_s6 = la_s2_8_a_s8;
    assert ((la_7_a_s6[0]) == (a_4[(spmdpid) * 2])); //Assert at tr1.sk:101 (-7290073739140730102)
    assert ((la_7_a_s6[1]) == (a_4[((spmdpid) * 2) + 1])); //Assert at tr1.sk:102 (-8967006543534396359)
    int lr_9_ntdivnp_s9;
    double[3] lr_9_a_s10;
    int lr_s4_a_ntdivnp_s11;
    double[3] lr_s4_a_a_s12;
    assert (nt_6 >= ((nx_1 * ny_2) * nz_3)); //Array Length Mismatch tr1.sk:104
    movein(P_0, spmdpid, nt_6, result_5, lr_s4_a_ntdivnp_s11, lr_s4_a_a_s12);
    lr_9_ntdivnp_s9 = lr_s4_a_ntdivnp_s11;
    lr_9_a_s10 = lr_s4_a_a_s12;
    spmdbarrier();
    transpose_xy_z(nx_1, ny_2, nz_3, la_7_ntdivnp_s5, la_7_a_s6, lr_9_ntdivnp_s9, lr_9_a_s10);
    assert ((lr_9_a_s10[0]) == (a_4[spmdpid])); //Assert at tr1.sk:107 (6809812447366254080)
    assert ((lr_9_a_s10[1]) == (a_4[2 + (spmdpid)])); //Assert at tr1.sk:108 (4829405631917912476)
    spmdbarrier();
    assert (nt_6 == ((nx_1 * ny_2) * nz_3)); //Array Length Mismatch tr1.sk:110
    moveout(P_0, spmdpid, nt_6, result_5, lr_9_ntdivnp_s9, lr_9_a_s10);
  }
}
/*tr1.sk:38*/

void spec (global int P_b, global int nx_c, global int ny_d, global int nz_e, global double[(nx_c * ny_d) * nz_e] a_f, ref global double[(nx_c * ny_d) * nz_e] result_10)/*tr1.sk:38*/
{
  assume ((P_b > 0) & (P_b <= 2)); //null
  assume (P_b == 2); //null
  assume ((ny_d % P_b) == 0); //null
  assume ((nz_e % P_b) == 0); //null
  assume (nx_c == 1); //null
  assume (ny_d == 2); //null
  assume (nz_e == 2); //null
  int y_11;
  for(y_11 = 0; y_11 < ny_d; y_11 = y_11 + 1)/*Canonical*/
  {
    int x_1a;
    for(x_1a = 0; x_1a < nx_c; x_1a = x_1a + 1)/*Canonical*/
    {
      int z_1d;
      for(z_1d = 0; z_1d < nz_e; z_1d = z_1d + 1)/*Canonical*/
      {
        result_10[((y_11 * (nx_c * nz_e)) + (x_1a * nz_e)) + z_1d] = a_f[((z_1d * (nx_c * ny_d)) + (y_11 * nx_c)) + x_1a];
      }
    }
  }
}
/*spmd.skh:80*/

void spmdalltoall (global int size_3d, double[size_3d] src_3e, ref double[size_3d] dst_3f)/*spmd.skh:80*/
{
  assert ((size_3d % (spmdnproc)) == 0); //Assert at spmd.skh:81 (-7656420182739026664)
  global int sz_40;
  sz_40 = size_3d / (spmdnproc);
  global double[size_3d][spmdnproc] buffer_41;
  spmdbarrier();
  int i_42;
  for(i_42 = 0; i_42 < (spmdnproc); i_42 = i_42 + 1)/*Canonical*/
  {
    int j_45;
    for(j_45 = 0; j_45 < sz_40; j_45 = j_45 + 1)/*Canonical*/
    {
      buffer_41[i_42][((spmdpid) * sz_40) + j_45] = src_3e[(i_42 * sz_40) + j_45];
    }
  }
  spmdbarrier();
  int k_46;
  for(k_46 = 0; k_46 < size_3d; k_46 = k_46 + 1)/*Canonical*/
  {
    dst_3f[k_46] = buffer_41[spmdpid][k_46];
  }
  spmdbarrier();
}
/*tr1.sk:72*/

void transpose_finish (global int n1_47, global int n2_48, double[n1_47 * n2_48] a_49, ref double[n1_47 * n2_48] b_4a)/*tr1.sk:72*/
{
  int p_4b;
  for(p_4b = 0; p_4b < (spmdnproc); p_4b = p_4b + 1)/*Canonical*/
  {
    int ioff_56;
    ioff_56 = (p_4b * n2_48) / (spmdnproc);
    int j_57;
    for(j_57 = 0; j_57 < n1_47; j_57 = j_57 + 1)/*Canonical*/
    {
      int i_5a;
      for(i_5a = 0; i_5a < (n2_48 / (spmdnproc)); i_5a = i_5a + 1)/*Canonical*/
      {
        b_4a[((j_57 * n2_48) + i_5a) + ioff_56] = a_49[((p_4b * ((n1_47 * n2_48) / (spmdnproc))) + ((j_57 * n2_48) / (spmdnproc))) + i_5a];
      }
    }
  }
}
/*tr1.sk:62*/

void transpose_local (global int n1_35, global int n2_36, double[n1_35 * n2_36] a_37, ref double[n1_35 * n2_36] b_38)/*tr1.sk:62*/
{
  int i_39;
  for(i_39 = 0; i_39 < n2_36; i_39 = i_39 + 1)/*Canonical*/
  {
    int j_3c;
    for(j_3c = 0; j_3c < n1_35; j_3c = j_3c + 1)/*Canonical*/
    {
      b_38[(j_3c * n2_36) + i_39] = a_37[(i_39 * n1_35) + j_3c];
    }
  }
}
/*tr1.sk:84*/

void transpose_xy_z (global int nx_27, global int ny_28, global int nz_29, int a_2a_ntdivnp_s16, double[3] a_2a_a_s17, ref int b_2b_ntdivnp_s18, ref double[3] b_2b_a_s19)/*tr1.sk:84*/
{
  assert (((nx_27 * ny_28) * (nz_29 / (spmdnproc))) >= a_2a_ntdivnp_s16); //Array Length Mismatch tr1.sk:85
  assert (((nx_27 * ny_28) * (nz_29 / (spmdnproc))) == b_2b_ntdivnp_s18); //Array Length Mismatch tr1.sk:85
  transpose_local(nx_27 * ny_28, nz_29 / (spmdnproc), a_2a_a_s17[0::a_2a_ntdivnp_s16], b_2b_a_s19[0::b_2b_ntdivnp_s18]);
  assert ((a_2a_a_s17[0]) == (b_2b_a_s19[0])); //Assert at tr1.sk:86 (8005861021202580)
  assert ((a_2a_a_s17[1]) == (b_2b_a_s19[1])); //Assert at tr1.sk:87 (-6824970841299721694)
  global int size_2c;
  size_2c = a_2a_ntdivnp_s16;
  assert (size_2c >= b_2b_ntdivnp_s18); //Array Length Mismatch tr1.sk:89
  assert (size_2c == a_2a_ntdivnp_s16); //Array Length Mismatch tr1.sk:89
  spmdalltoall(size_2c, b_2b_a_s19[0::b_2b_ntdivnp_s18], a_2a_a_s17[0::a_2a_ntdivnp_s16]);
  assert ((((nx_27 * ny_28) / (spmdnproc)) * nz_29) >= a_2a_ntdivnp_s16); //Array Length Mismatch tr1.sk:90
  assert ((((nx_27 * ny_28) / (spmdnproc)) * nz_29) == b_2b_ntdivnp_s18); //Array Length Mismatch tr1.sk:90
  transpose_finish((nx_27 * ny_28) / (spmdnproc), nz_29, a_2a_a_s17[0::a_2a_ntdivnp_s16], b_2b_a_s19[0::b_2b_ntdivnp_s18]);
  assert ((a_2a_a_s17[0]) == (b_2b_a_s19[0])); //Assert at tr1.sk:91 (6717372329922674370)
  assert ((a_2a_a_s17[1]) == (b_2b_a_s19[1])); //Assert at tr1.sk:92 (1062562120606721536)
}
