//@Description Queue module, should run with size 1

var {
    queue empty_out;

    queue enq_q;
    int enq_v;
    queue enq_out;

    queue deq_q;
    boolean deq_err;
    queue deq_out;

    queue front_q;
    boolean front_err;
    int front_out;

    boolean err;
}

relation {
    empty_queue(empty_out);
    enqueue(enq_q, enq_v, enq_out);
    dequeue(deq_q, deq_err, deq_out);
    front(front_q, front_err, front_out);
}

generator {
    boolean AP -> !COMP || !GUARD || RHS;
    boolean COMP -> equal_queue(QV, QV) | IV == IV;
    boolean GUARD -> true | is_empty_queue(Q0) | !is_empty_queue(Q0);
    boolean RHS -> ERR | IV == I | equal_queue(QV, Q) ;
    boolean ERR -> deq_err | front_err | err; 
    int IV -> enq_v | front_out;
    int I -> IV | front(Q0, err) | front(Q1, err);
    queue QV -> enq_q | deq_q | front_q | enq_out | deq_out | empty_out;
    queue Q0 -> enq_q | deq_q | front_q;
    queue Q1 -> enqueue(Q0, IV) | dequeue(Q0, err) | empty_out | enq_out | deq_out;
    queue Q2 -> enqueue(Q1, IV) | dequeue(Q1, err);
    queue Q -> Q0 | Q1 | Q2; 
}

example {
    int -> ??(3) | -1 * ??(3) ;
    boolean -> true | false;
    queue(3) -> empty_queue() | enqueue(queue, int) | dequeue(queue, boolean) ;
}

struct list {
    int hd;
	list tl;
}

void nil(ref list ret) {
    ret = null;
}

void cons(int hd, list tl, ref list ret) {
    ret = new list();
    ret.hd = hd;
    ret.tl = tl;
}

void head(list l, ref int ret) {
    assert (l != null);

    ret = l.hd;
}

void tail(list l, ref list ret) {
    assert (l != null);

    ret = l.tl;
}

void snoc(list l, int val, ref list ret) {
    if (l == null) {
        ret = new list();
        ret.hd = val;
        ret.tl = null;
    } else {
        ret = new list();
        ret.hd = l.hd;
        snoc(l.tl, val, ret.tl);
    }
}

void reverse(list l, ref list ret) {
    if (l == null) {
        ret = null;
    } else {
        list tl_reverse;
        reverse(l.tl, tl_reverse);
        snoc(tl_reverse, l.hd, ret);
    }
}

void append(list l1, list l2, ref list ret) {
    if (l1 == null) {
        ret = l2;
    } else {
        list tl_append;
        append(l1.tl, l2, tl_append);
        cons(l1.hd, tl_append, ret);
    }
}

void list_len(list l, ref int ret) {
    if (l == null) {
        ret = 0;
    } else {
        list_len(l.tl, ret);
        ret = ret + 1;
    }
}

void is_empty_list(list l, ref boolean ret) {
    ret = (l == null);
}

void equal_list(list l1, list l2, ref boolean ret) {
    if (l1 == null || l2 == null) {
        ret = l1 == l2;
    } else {
        equal_list(l1.tl, l2.tl, ret);
        ret = l1.hd == l2.hd && ret;
    }
}

struct queue {
	list in_list;
    list out_list;
}

void empty_queue(ref queue ret) {
    ret = new queue();
    nil(ret.in_list);
    nil(ret.out_list);
}

void is_empty_queue(queue q, ref boolean ret) {
    is_empty_list(q.out_list, ret);
}

void enqueue(queue q, int val, ref queue ret) {
    if (q == null) {
        ret = null;
    } else {
        ret = new queue();
        if (q.out_list == null) {
            ret.in_list = q.in_list;
            cons(val, q.out_list, ret.out_list);
        } else {
            cons(val, q.in_list, ret.in_list);
            ret.out_list = q.out_list;
        }
    }
}

void front(queue q, ref boolean error, ref int v_out) {
    if (q.out_list == null || q == null) {
        v_out = 0;
        error = true;
    } else {
        v_out = q.out_list.hd;
        error = false;
    }
}

void dequeue(queue q, ref boolean error, ref queue q_out) {
    if (q.out_list == null || q == null) {
        error = true;
        q_out = null;
    } else {
        error = false;
        q_out = new queue();
        if (q.out_list.tl == null) {
            nil(q_out.in_list);
            reverse(q.in_list, q_out.out_list);
        } else {
            q_out.in_list = q.in_list;
            q_out.out_list = q.out_list.tl;
        }
    }
}

void queue_len(queue q, ref int ret) {
    int len_in_list;
    int len_out_list;

    list_len(q.in_list, len_in_list);
    list_len(q.out_list, len_out_list);
    ret = len_in_list + len_out_list;
}

void queue2list(queue q, ref list ret) {
    assume (q != null);

    list rev_in_list;
    reverse(q.in_list, rev_in_list);
    append(q.out_list, rev_in_list, ret);
}

void equal_queue(queue q1, queue q2, ref boolean ret) {
    list q1_list;
    list q2_list;

    if (q1 == null || q2 == null) {
        ret = false;
    } else {
        queue2list(q1, q1_list);
        queue2list(q2, q2_list);

        equal_list(q1_list, q2_list, ret);
    }
}