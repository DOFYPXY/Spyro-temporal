//@Description Queue module, should run with size 1

var {
    queue q;
    int v;
    queue enq_out;

    queue deq_out;
}

relation {
    enqueue(q, v, enq_out);
    dequeue(enq_out, deq_out);
}

generator {
    boolean AP -> !GUARD || RHS;
    boolean GUARD -> true | is_empty_queue(q) | !is_empty_queue(q);
    boolean RHS -> equal_queue(deq_out, Q);
    queue Q -> empty_queue() | q | dequeue(q) | enqueue(Q, v);
}

example {
    int -> ??(3) | -1 * ??(3) ;
    boolean -> true | false;
    queue(3) -> empty_queue() | enqueue(queue, int) | dequeue(queue) ;
}

adt Stack {
    Empty { }
	Push { Stack s; int x; }
    Pop { Stack s; }
}

void rewrite_isEmpty(Stack st, ref boolean ret) {
    switch(st) {
        case Empty: { ret = true; }
        case Push: { ret = false; }
        case Pop: { assert false; }
    }
}

void rewrite_Equal(Stack st1, Stack st2, ref boolean ret) {
    switch(st1) {
        case Empty: { rewrite_isEmpty(st2, ret); }
        case Push: { 
            boolean b;
            rewrite_isEmpty(st2, b);
            if (b) {
                ret = false;
            } else {
                int x;
                rewrite_Top(st2, x);
                if (st1.x == x) {
                    Stack s;
                    rewrite_Pop(st2, s);
                    rewrite_Equal(st1.s, s, ret);
                } else {
                    ret = false;
                }
            }
        }
        case Pop: { assert false; }
    }
}

void rewrite_Top(Stack st, ref int ret) {
    switch(st) {
        case Empty: { assert false; }
        case Push: { ret = st.x; }
        case Pop: { assert false; }
    }
}

void rewrite_Pop(Stack st, ref Stack ret) {
    switch(st) {
        case Empty: { ret = new Pop(s=st); }
        case Push: { ret = st.s; }
        case Pop: { ret = new Pop(s=st); }
    }
}

void empty(ref Stack ret) {
    ret = new Empty();
}

void push(Stack st, int x, ref Stack ret) {
    ret = new Push(s=st, x=x);
}

void top(Stack st, ref int ret) {
    rewrite_Top(st, ret);
}

void pop(Stack st, ref Stack ret) {
    rewrite_Pop(st, ret);
}

void is_empty_stack(Stack st, ref boolean ret) {
    rewrite_isEmpty(st, ret);
}

void equal_stack(Stack st1, Stack st2, ref boolean ret) { 
    rewrite_Equal(st1, st2, ret);
}

struct queue {
	Stack pushStack;
    Stack popStack;
}

void empty_queue(ref queue ret) {
    ret = new queue();
    empty(ret.pushStack);
    empty(ret.popStack);
}

void is_empty_queue(queue q, ref boolean ret) {
    is_empty_stack(q.popStack, ret);
}

void enqueue(queue q, int val, ref queue ret) {
    if (q == null) {
        ret = null;
    } else {
        ret = new queue();
        boolean b;
        is_empty_stack(q.popStack, b);
        if (b) {
            ret.pushStack = q.pushStack;
            push(q.popStack, val, ret.popStack);
        } else {
            push(q.pushStack, val, ret.pushStack);
            ret.popStack = q.popStack;
        }
    }
}

void front(queue q, ref int v_out) {
    boolean b;
    is_empty_stack(q.popStack, b);
    if (b) {
        v_out = 0;
    } else {
        top(q.popStack, v_out);
    }
}

void reverse(Stack st, ref Stack ret) {
    boolean b;
    Stack st_iter = st;

    empty(ret);
    is_empty_stack(st_iter, b);
    while(!b) {
        int x;
        top(st_iter, x);

        Stack st_tmp;
        pop(st_iter, st_tmp);
        st_iter = st_tmp;
        
        Stack ret_tmp;
        push(ret, x, ret_tmp);
        ret = ret_tmp;

        is_empty_stack(st_iter, b);
    }
}

void dequeue(queue q, ref queue q_out) {
    boolean b;
    is_empty_stack(q.popStack, b);
    if (b) {
        empty_queue(q_out);       
    }
    else {
        q_out = new queue();
        
        Stack st;

        pop(q.popStack, st);
        is_empty_stack(st, b);
        if (b) {
            empty(q_out.pushStack);
            reverse(q.pushStack, q_out.popStack);
        } else {
            q_out.pushStack = q.pushStack;
            q_out.popStack = st;
        }
    }
}

void equal_queue(queue q1, queue q2, ref boolean ret) {
    queue q1d;
    queue q2d;

    int x1;
    int x2;

    boolean b1;
    boolean b2;

    if (q1 == null || q2 == null) {
        ret = false;
    } else {
        is_empty_queue(q1, b1);
        is_empty_queue(q2, b2);

        if (b1) {
            ret = b2;
        } else if (b2) {
            ret = false;
        } else {
            front(q1, x1);
            front(q2, x2);

            if (x1 == x2) {
                dequeue(q1, q1d);
                dequeue(q2, q2d);
                equal_queue(q1d, q2d, ret);                
            } else {
                ret = false;
            }
        }
    }
}