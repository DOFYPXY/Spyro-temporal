//@Description Toy benchmarks to show complex recursive generators.

void max2(int x, int y, ref int out){
    if (x > y) {
        out = x;
    } else {
        out = y;
    }
}

generator boolean boolGen(int x, int y, int o){ /* automatically rewritten */
    int t = ??;

    int leftInt = intGen(x, y, o);
    int rightInt = intGen(x, y, o);

    if(t == 0) { return leftInt < rightInt; }
    if(t == 1) { return leftInt <= rightInt; }
    if(t == 2) { return leftInt == rightInt; }

    boolean leftBool = boolGen(x, y, o);
    boolean rightBool = boolGen(x, y, o);

    if(t == 3) { return leftBool && rightBool; }
    if(t == 4) { return leftBool || rightBool; }
    if(t == 5) { return !leftBool; }
}

generator int intGen(int x, int y, int o) {
   int t = ??;
   if(t == 0){
     return x;
   }

   if(t == 1){
     return y;
   }

   if(t == 2){
     return o;
   }
}


void property( int x, int y, int o, ref boolean out ){
   out = boolGen(x, y, o);
}


void obtained_property(int x, int y, int o, ref boolean out){
    OBTAINED_PROPERTY
}

harness void soundness() {
    int x = ??;
    int y = ??;
    int o;
    
    max2(x, y, o);

    boolean out;
    obtained_property(x, y, o, out);
    assert !out;
}

harness void precision() {
    int x = ??;
    int y = ??;
    int o = ??;

    boolean out_1;
    obtained_property(x, y, o, out_1);
    assert out_1;

    boolean out_2;
    property(x, y, o, out_2);
    assert !out_2;
}
