//@Description need inline bnd 10

var {
    list elem_in_list;
    int elem_in_val;
    boolean elem_out_val;
}

relation {
    elem(elem_in_list, elem_in_val, elem_out_val);
}

generator {
    boolean AP -> U | E | is_empty(L) | !is_empty(L) | elem_out_val | !elem_out_val;
    boolean U -> forall((x) -> x <= I, L) | forall((x) -> x == I, L) | forall((x) -> x >= I, L) | forall((x) -> x != I, L)  ;
    boolean E -> exists((x) -> x <= I, L) | exists((x) -> x == I, L) | exists((x) -> x >= I, L) | exists((x) -> x != I, L)  ;
    list L -> elem_in_list ;
    int I -> elem_in_val ;
}

example {
    int -> ??(3) | -1 * ??(3) ;
    boolean -> ?? ;
    list -> nil() | cons(int, list);
}

struct list {
    int hd;
	list tl;
}

void nil(ref list ret) {
    ret = null;
}

void cons(int hd, list tl, ref list ret) {
    ret = new list();
    ret.hd = hd;
    ret.tl = tl;
}

void head(list l, ref int ret) {
    assert (l != null);

    ret = l.hd;
}

void tail(list l, ref list ret) {
    assert (l != null);

    ret = l.tl;
}

void elem(list l, int val, ref boolean ret) {
    if (l == null) {
        ret = false;
    } else if (val == l.hd) {
        ret = true;
    } else {
        elem(l.tl, val, ret);
    }
}

void forall(fun f, list l, ref boolean ret) {
    if (l == null) {
        ret = true;
    } else {
        forall(f, l.tl, ret);        
        ret = ret && f(l.hd);
    }
}

void exists(fun f, list l, ref boolean ret) {
    if (l == null) {
        ret = false;
    } else {
        exists(f, l.tl, ret);
        ret = ret || f(l.hd);
    }
}

void is_empty(list l, ref boolean ret) {
    ret = (l == null);
}

void equal_list(list l1, list l2, ref boolean ret) {
    if (l1 == null || l2 == null) {
        ret = l1 == l2;
    } else {
        equal_list(l1.tl, l2.tl, ret);
        ret = l1.hd == l2.hd && ret;
    }
}