//@Description Sketch to reverse a list.

var {
    queue enqueue_input_queue;
    int enqueue_input_val;
    queue enqueue_out_queue;
}

relation {
    enqueue(enqueue_input_queue, enqueue_input_val, enqueue_out_queue);
}

generator {
    boolean AP -> seq_equal(S, S) | !seq_equal(S, S);
    int I -> enqueue_input_val;
    seq S -> AS | append(AS, I) | prepend(AS, I);
    seq AS -> queue2seq(Q) | empty_seq();
    queue Q -> enqueue_input_queue | enqueue_out_queue;
}

example {
    int -> ??(3) | -1 * ??(3) ;
    queue(3) -> empty() | enqueue(queue, int) ;
    seq(3) -> empty_seq() | prepend(seq, int) ;
}

struct node {
	node next;
	int val;	
}

struct queue {
	node front;
    node rear;
}

struct seq {
    node head;
}

void queue2seq(queue q, ref seq out) {
    out = new seq();
    
    node cur = q.front;
    node head = null;

    while (cur != null) {
        node n = new node();
        n.val = cur.val;
        n.next = head;

        cur = cur.next;
        head = n;
    }

    out.head = head;
}

void empty_seq(ref seq out) {
    out = new seq();
    out.head = null;
}

void node_copy(node n, ref node out) {
    if (n == null) {
        out = null;
    } else {
        out = new node();
        out.val = n.val;

        node next_copy;
        node_copy(n.next, next_copy);
        out.next = next_copy;
    }
}

void queue_copy(queue q, ref queue out) {
    node front_copy;
    node_copy(q.front, front_copy);

    out = new queue();
    out.front = front_copy;

    if (front_copy == null) {
        out.rear = null;
    } else {
        node cur = out.front;
        while (cur.next != null) { cur = cur.next; }
        out.rear = cur;
    }
}

void append(seq s, int val, ref seq out) {

    node n = new node();
    n.val = val;
    n.next = null;

    out = new seq();
    if (s.head == null) {
        out.head = n;
    } else {
        node s_head_copy;
        node_copy(s.head, s_head_copy);
        out.head = s_head_copy;

        node cur = s_head_copy;
        while(cur.next != null) { cur = cur.next; }
        cur.next = n;
    }
}

void prepend(seq s, int val, ref seq out) {
    node head = new node();
    head.val = val;
    head.next = s.head;

    out = new seq();
    out.head = head;
}

void empty(ref queue ret) {
    ret = new queue();
    ret.front = null;
    ret.rear = null;
}

void enqueue(queue q, int val, ref queue ret) {
    assert q != null;

    node n = new node();
    n.val = val;
    n.next = null;

    ret = new queue(); 
    if (q.rear != null) {
        queue_copy(q, ret);
        ret.rear.next = n;
    } else {
        ret.front = n;
        ret.rear = n;
    }
}

void dequeue(queue q, ref queue out_queue, ref int out_val) {
    assert q != null;
    assert q.front != null;
    
    out_queue = new queue();
    out_queue.front = q.front.next;
    out_val = q.front.val;

    if (out_queue.front == null) {
        out_queue.rear = null;
    } else {
        out_queue.rear = q.rear;
    }
}

boolean node_equal(node n1, node n2) {
    if (n1 == null || n2 == null) {
        return n1 == n2;
    } else {
        return n1.val == n2.val && node_equal(n1.next, n2.next);
    }
}

void queue_equal(queue q1, queue q2, ref boolean out) {
    if (q1 == null || q2 == null) {
        out = q1 == q2;
    } else {
        out = node_equal(q1.front, q2.front);
    }
}

void seq_equal(seq s1, seq s2, ref boolean out) {
    if (s1 == null || s2 == null) {
        out = s1 == s2;
    } else {
        out = node_equal(s1.head, s2.head);
    }    
}