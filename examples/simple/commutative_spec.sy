(set-logic LIA)

(define-fun comm ((x Int) (y Int)) Int (+ x y))

(define-fun comm_prob ((x1 Int) (y1 Int) (x2 Int) (y2 Int) (o1 Int) (o2 Int)) Bool
    (and 
        (= o1 (comm x1 y1))
        (= o2 (comm x2 y2))
        (= x1 y2)
        (= x2 y1)
    )
)

(synth-fun comm_spec ((x1 Int) (y1 Int) (x2 Int) (y2 Int) (o1 Int) (o2 Int)) Bool
    ;; Declare the non-terminals that would be used in the grammar
    ((B Bool) (I Int))

    ;; Define the grammar for allowed implementations of max2
    ((B Bool ((and B B) (or B B) (not B) (= I I)))
     (I Int (x1 y1 x2 y2 o1 o2)))
)

(declare-var x1 Int)
(declare-var x2 Int)
(declare-var y1 Int)
(declare-var y2 Int)
(declare-var o1 Int)
(declare-var o2 Int)

;; Problem Part
(constraint (=> (comm_prob x1 y1 x2 y2 o1 o2) (comm_spec x1 y1 x2 y2 o1 o2)))

;; Iterative Solving
;;(constraint 
;;   (exists 
;;        ((x1 Int) (x2 Int) (y1 Int) (y2 Int) (o1 Int) (o2 Int))
;;        (not (=> 
;;            (= y1 y1) 
;;            (comm_spec x1 y1 x2 y2 o1 o2)
;;        ))
;;    )
;;)

(constraint 
   (exists 
        ((x1 Int) (x2 Int) (y1 Int) (y2 Int) (o1 Int) (o2 Int))
        (not (=> 
            (and (= o1 o2) (= x1 y2) (= x2 y1))
            (comm_spec x1 y1 x2 y2 o1 o2)
        ))
    )
)

(check-synth)