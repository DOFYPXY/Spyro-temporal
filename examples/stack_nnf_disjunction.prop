//@Description Sketch to reverse a list.
pragma options "--bnd-unroll-amnt 10";

struct node {
	node next;
	int val;	
}

struct stack {
	node top;
}

void push(stack s, int val, ref stack ret) {
    assert s != null;

    node n = new node();
    n.val = val;
    n.next = s.top;

    ret = new stack();   
    ret.top = n;
}

void pop(stack s, ref stack out_stack, ref int out_val) {
    assert s != null;
    assert s.top != null;
    
    out_stack = new stack();
    out_stack.top = s.top.next;
    out_val = s.top.val;
}

boolean node_equal(node n1, node n2) {
    if (n1 == null || n2 == null) {
        return n1 == n2;
    } else {
        return n1.val == n2.val && node_equal(n1.next, n2.next);
    }
}

void stack_equal(stack s1, stack s2, ref boolean out) {
    if (s1 == null || s2 == null) {
        out = s1 == s2;
    } else {
        out = node_equal(s1.top, s2.top);
    }
}

generator int intGen(int x, int y) {
   int t = ??;
   if(t == 0){ return x; }
   if(t == 1){ return y; }
}

generator stack stackGen(stack s1, stack s2, stack s3, stack s4) {
    int t = ??;
    if (t == 0) { return s1; }
    if (t == 1) { return s2; }
    if (t == 2) { return s3; }
    if (t == 3) { return s4; }
}

generator boolean propertyGen(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack
) { /* automatically rewritten */
    int t = ??;

    int leftInt = intGen(push_input_val, pop_out_val);
    int rightInt = intGen(push_input_val, pop_out_val);

    if(t == 0) { return leftInt < rightInt; }
    if(t == 1) { return leftInt <= rightInt; }
    if(t == 2) { return leftInt == rightInt; }
    if(t == 3) { return leftInt != rightInt; }

    stack leftStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );
    stack rightStack = stackGen(
        push_input_stack, push_out_stack, 
        pop_input_stack, pop_out_stack
    );

    if(t == 4) { 
        boolean out;
        stack_equal(leftStack, rightStack, out); 
        return out;
    }

    if(t == 5) { 
        boolean out;
        stack_equal(leftStack, rightStack, out); 
        return !out;
    }

    boolean leftBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack,
        pop_input_stack, pop_out_val, pop_out_stack
    );

    boolean rightBool = propertyGen(
        push_input_stack, push_input_val, push_out_stack,
        pop_input_stack, pop_out_val, pop_out_stack
    );

    if(t == 6) { return leftBool || rightBool; }
}

void property(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack, 
    ref boolean out
) {
    out = propertyGen(
        push_input_stack, push_input_val, push_out_stack, 
        pop_input_stack, pop_out_val, pop_out_stack
    );
}

void obtained_property(
    stack push_input_stack, int push_input_val, stack push_out_stack, 
    stack pop_input_stack, int pop_out_val, stack pop_out_stack,
    ref boolean out
) {
    OBTAINED_PROPERTY
}

harness void soundness() {
    int push_input_val = ??;
    stack push_input_stack = ??;
    stack push_out_stack;

    stack pop_input_stack = ??;
    stack pop_out_stack;
    int pop_out_val;

    push(push_input_stack, push_input_val, push_out_stack);   
    pop(pop_input_stack, pop_out_stack, pop_out_val);
    
    // new positive example c is not included in [[ phi ]]
    // c in [[ P ]] since output variables are the result of implementation
    
    boolean out;
    obtained_property(
        push_input_stack, push_input_val, push_out_stack,
        pop_input_stack, pop_out_val, pop_out_stack, out
    );
    assert !out;
}


harness void precision() {
    stack push_input_stack = ??;
    int push_input_val = ??;
    stack push_out_stack = ??;

    stack pop_input_stack = ??; 
    int pop_out_val = ?? ;
    stack pop_out_stack = ??;

    // new negative example c is in [[ phi ]]
    boolean out_1;
    obtained_property(
        push_input_stack, push_input_val, push_out_stack,
        pop_input_stack, pop_out_val, pop_out_stack, out_1
    );
    assert out_1;

    // new negative example c is not in [[ phi' ]]
    boolean out_2;
    property(
        push_input_stack, push_input_val, push_out_stack,
        pop_input_stack, pop_out_val, pop_out_stack, out_2
    );
    assert !out_2;
}
